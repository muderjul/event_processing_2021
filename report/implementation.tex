We can split our implementation into 4 different parts:
\begin{enumerate}
  \item Dataset Generation
  \item main.py
  \item Windowing Library
  \item FlatFAT and Reactive Aggregator
\end{enumerate}

\subsection{Data Generation}

\ldots

\subsection{main.py}
We implemented our main method in a way that allows us to run a lot of tests sequentially
and quickly give us information on how those turned out as well as show a progress of the
currently running tests without cluttering the output.
Additionally we included a wrapper for coordinating a test with fixed window sizes due
to a possible bug in our implementation that lead to our FlatFAT being full all while trying
to add more tuples which lead to the FlatFAT resizing to twice the size and therefore
losing a lot of speed due to unnecessary array length.

\subsection{Windowing Library}
We implemented our windowing library to provide the FlatFAT with our previously generated
data streams in a manageable format. We focused mainly on utility over speed since we
decided to only measure time spent in the Reactive Aggregator.
Measuring time was therefore also implemented in the windowing library, including a
180 second test timeout to speed up the runs of the test suite.

\subsection{Reactive Aggregator}
Since the scope of our implementation was limited to the ArgMax aggregation function
our reactive aggregator is rather basic. We mainly interfaced the methods of FlatFAT
and added additional checks for resizing the tree when necessary as outlined in the paper.

\subsection{FlatFAT}
The FlatFAT is the core of our implementation. We decided to implement the binary tree
as a list using the knowledge about the amount of nodes in a full binary tree to determine
which index in the list represents which node and which indices represent leafs.

% TODO TEXT FORMATTING OF FUNCION NAMES IN FOLLOWING PART
In addition to the public functions {update, aggregate, prefix} and {suffix} we
added the internal function {combine} for updating only changed parts of the tree
efficiently in case of a call to {new} or {update}. The main difference between
{update} and {new} is that {new} will disregard some checks that are necessary for
the update function, we will omit further explanation for brevity here.

\subsubsection{prefix, suffix and aggregate}
Since we limited our scope to FIFO and events being in order we decided to omit
front and back of buffer pointers as well as the compact function and use any free
space in the leaf-part of the list. Unfortunately this also means that we need
to search for this free space in the list which is our most expensive operation.
This means that {prefix(n)} returns the aggregated value (in our case ArgMax) of the
first $n$ entries while {suffix(n)} returns the aggregated value of the last $n$ entries
similarly. Note that this does not represent the newest and oldest entries but simply
first and last as ordered internally.
{aggregate} will in turn return only the root entry which always holds the aggregated
value over all leafs.

\subsubsection{update}
\ldots
For any $insert$ call we simply search for the first empty space (encoded with None) %TODO MAYBE FORMAT NONE HERE
while for any $trigger$ and $evict$ call we simply search for the first (and only) occurence of
an entry with matching argument.
Once we found the spot in our list we update it accordingly and add this index to a
list of updated indices which we will pass to {combine} once all new tuples have been
taken care of.


\subsubsection{combine}
\ldots
